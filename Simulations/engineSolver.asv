%% Engine Solver
% Isolate engine 




function out = engineSolver(in)
%% INPUT (struct 'in')
%   .nozzle      – geometry sub‑struct
%   [ChamberLength, ChamberRadius, ExitRadius, ThroatRadius, NozzleLength, BlendRadius, ConvergingAngle, DivergingAngle, ExitAngle]
%   .prop      – propellant & CEA sub‑struct
%   [TransportCEA]
%   .cool      – coolant & channel sub‑struct
%   [Ncc, WallThickness, Height, Width, FinWidth]
%   .material
%   [YoungsModulus, CTE, Poisson, SurfaceRoughness, Strength, Conductivity, MaxTemperature]
%   .environment    - Actual "inputs" into the engine
%   [AmbientPressure, FuelPressure, FuelTemperature, OxPressure]
%   .numerics   - Useful for simulation refinement 
%   [simDx, dt]
%   .injector     - Injector information
%   [OxOrifices, FuelOrifices, OxDiameter, FuelDiameter, OxCd, FuelCd]
%% OUTPUT (struct 'out')
%   .station   - x values at which values are computed 
%   .coolant
%   [VaporState, Temperature, Pressure, Velocity]
%   .nozzle
%   [Temperature, Pressure, MachNumber]
%   .chamber
%   [HotWallTemperature, ColdWallTemperature, Stress]
%   .mass
%   [MdotO, MdotF]
%   .meta    - remember input file 
%   .meta = in

%% Stage 0 Setup

% Store input metadata
out.meta = in;

% Output station positions used for calculations
out.station = (0:in.numerics.simDx:(in.nozzle.ChamberLength + in.nozzle.NozzleLength));

% Generate geometry data for all other processes

x = out.station;

[StationRad, StationArea] = combustionChamberProfile(x, in.geom.ChamberRadius, ...
        in.geom.BlendRadius, in.geom.ConvergingAngle, in.geom.BlendRadius, in.geom.ThroatRadius, in.geom.ChamberLength, ...
        in.geom.DivergingAngle, in.geom.ExitRadius, in.geom.ExitAngle,in.geom.NozzleLength);


OxArea = in.injector.OxDiameter^2 * 0.25 * pi * in.injector.OxOrifices;
FuelArea = in.injector.FuelDiameter^2 * 0.25 * pi * in.injector.FuelOrifices;

%% Stage 1 Sim
converged = false;
PC = 300 * 6894.76; % First guess chamber pressure
Pdrop = 100 * 6894.76;  % First guess pressure drop across channels
while ~converged
    % Calculate oxidizer and fuel densities
    rhoO = 1220;
    rhoF = 786;  %% OVERIDE WITH ACTUAL LOOKUP TABLES PLS
    % Calculate mass flow of oxidiser based on first guess chamber
    % pressure and external feed pressure
    MdotO = OxArea * in.injector.OxCd * sqrt(2 * rhoO * (in.environment.OxPressure-PC));
    % Calculate mass flow of fuel based on first guess chamber pressure,
    % first guess pressure drop over regen channels, and feed pressure
    MdotF = FuelArea * in.injector.FuelCd * sqrt(2 * rhoF * (in.environment.FuelPressure - Pdrop - PC));
    % Calculate first o/f ratio
    of = MdotO/MdotF;
    % Calculate thermo stuff based on o/f and PC  %% THIS IS MISSING PC
    % INPUT ON THE SOLVER!!!! NEED NEW CEA DATA UGHHHH
    Tcomb   = ceaGridInterp('rocketCEAgrid.csv','T_c', PC, of);
    GammaC = ceaGridInterp('rocketCEAgrid.csv','gamma_c',  PC, of);
    Cp = ceaGridINterp('rocketCEAgrid.csv', 'Cp_c', PC, of);
    Cv = Cp/GammaC;
    Rgas = Cp - Cv;
    % Calculate required mass flow from nozzle based on thermo properties
    Pratio = in.environment.AmbientPressure/PC;
    PratioCritical = (2/(GammaC + 1))^(GammaC/(GammaC-1)s);
    if(Pratio < PratioCritical)
        % Choked flow
        RealMdot = PC * min(stationArea) * (Tcomb)^-0.5 * sqrt(GammaC/Rgas) * (0.5*(GammaC + 1))^((-1 - GammaC)/(2 * (GammaC -1)));
    else
        
    end
    % Compute mass flow error, use to scale new chamber pressure
    % Calculate mach number along nozzle length, temperature, and pressure,
    % including logic for subsonic/supersonic/shock wave in expanding
    % section solutions 
    % Calculate heating equilibrium for hot wall, cold wall, coolant
    % temperature, and coolant pressure along the channel. 
    % Establish new pressure drop 
    % Compare new pressure drop with old pressure drop guess for error
    % value 
    % Adjust pressure drop based on error values

    % Check for convergance where errors are both within bounds
end



end